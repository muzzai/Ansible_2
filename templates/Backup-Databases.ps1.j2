$ConnectionString = "Server={{ ServerInstance }};User ID={{ SaUserName }};Password={{ SaPassword }};Encrypt=True;TrustServerCertificate=True;Database=master"
$Engine = Invoke-Sqlcmd -ConnectionString $ConnectionString -Query "select serverproperty('EngineEdition') as [Edition]"
Write-Output "SQL server edition: $($Engine.Edition)"

if ($Engine.Edition -ne 4) {
    $CompressionOption = "On"
}
else {
    $CompressionOption = "Default"
}
Write-Output "Compression Option: $CompressionOption"

$SecurePassword = ConvertTo-SecureString '{{ SaPassword }}' -AsPlainText -Force
$Credentials = New-Object System.Management.Automation.PSCredential ('{{ SaUserName }}', $SecurePassword)

$TempFolder = {{ TempFolder | quote }}
Remove-Item $TempFolder -Recurse -Force -ErrorAction SilentlyContinue
New-Item -Path $TempFolder -ItemType Directory | Out-Null

function BackupDatabase($Database) {
    $BackupTemp = Join-Path $TempFolder "$Database.bak"
    $BackupFinal = "D:\Backups\$Database.bak"

    # Build SQL query for backup only (single session)
    $query = @"
ALTER DATABASE [$Database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
BACKUP DATABASE [$Database] TO DISK = N'$BackupTemp' WITH COMPRESSION, INIT;
ALTER DATABASE [$Database] SET MULTI_USER;
"@

    Write-Output "Starting backup of $Database..."
    Invoke-Sqlcmd -ConnectionString $ConnectionString -Query $query

    # Wait until backup file exists
    while (-not (Test-Path $BackupTemp)) {
        Start-Sleep -Seconds 1
    }

    # Move backup to final destination
    Move-Item -Path $BackupTemp -Destination $BackupFinal -Force
    Write-Output "Backup moved to $BackupFinal"

    # Optional: set database offline
    Invoke-Sqlcmd -ConnectionString $ConnectionString -Query "ALTER DATABASE [$Database] SET OFFLINE WITH ROLLBACK IMMEDIATE"
    Write-Output "$Database is now offline"
}

BackupDatabase {{ AN_Database | quote }}
{% if not ADC_NetworkInventory %}
BackupDatabase {{ AD_Database | quote }}
{% endif %}

Remove-Item $TempFolder -Recurse -Force
