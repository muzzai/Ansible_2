################################################################
#                  CONFIGURATION SECTION                       #
################################################################

$AN_SQLDatabase      = "{{ database_list | select('search', 'Navigator') | first }}"
$SQLServerInstance   = "{{ new_hostname }},51967"
$AN_AccessKeyName    = "$SQLServerInstance : $AN_SQLDatabase"
$SaUser              = "{{ dest_SaUserName }}"
$SaPassword          = "{{ dest_SaPassword }}"


################################################################
#                      MAIN SCRIPT                             #
################################################################
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

if (-not (Get-PackageProvider -Name NuGet -ErrorAction SilentlyContinue)) {
    Install-PackageProvider -Name NuGet -Force
}

if ((Get-PSRepository PSGallery).InstallationPolicy -ne 'Trusted') {
    Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
}

if (-not (Get-Module -ListAvailable -Name SqlServer)) {
    Install-Module -Name SqlServer -Scope AllUsers -Force -AllowClobber
}

if (-not (Get-Module -ListAvailable -Name WebAdministration)) {
    Install-Module -Name WebAdministration -Scope AllUsers -Force -AllowClobber
}


Import-Module SqlServer -ErrorAction Stop
Import-Module WebAdministration -ErrorAction Stop


$SecurePass = ConvertTo-SecureString $SaPassword -AsPlainText -Force
$Cred       = New-Object System.Management.Automation.PSCredential ($SaUser, $SecurePass)

{% for db in database_list %}
Write-Host "=== Processing database: {{ db }} ==="

# -------------------------------
# Restore database
# -------------------------------
$decrypted = C:\Install\ScriptHelper.exe DecryptAccessKey "D:\RegFiles\{{ db }}.reg"

$password = (($decrypted -split '`n' | where {$_ -like "Password*"}) -split ': ')[1]

$restoreSql = @"
DECLARE @DataPath NVARCHAR(260);
DECLARE @LogPath  NVARCHAR(260);
DECLARE @Sql NVARCHAR(MAX);

SELECT
    @DataPath = CAST(SERVERPROPERTY('InstanceDefaultDataPath') AS NVARCHAR(260)),
    @LogPath  = CAST(SERVERPROPERTY('InstanceDefaultLogPath')  AS NVARCHAR(260));

SET @Sql = N'
RESTORE DATABASE [{{ db }}]
FROM DISK = ''{{ target_mssql_backup_path }}\{{ db }}.bak''
WITH
    MOVE ''{{ db }}''     TO ''' + @DataPath + '{{ db }}.mdf'',
    MOVE ''{{ db }}_log'' TO ''' + @LogPath  + '{{ db }}_log.ldf'',
    REPLACE,
    STATS = 5;
';

EXEC (@Sql);

IF DB_ID('{{ db }}') IS NOT NULL
BEGIN
    ALTER DATABASE [{{ db }}] SET ONLINE;
    ALTER DATABASE [{{ db }}] SET MULTI_USER WITH ROLLBACK IMMEDIATE;
END
"@

Invoke-Sqlcmd -ServerInstance $SQLServerInstance `
              -Credential $Cred `
              -Database master `
              -Query $restoreSql `
              -TrustServerCertificate `
              -QueryTimeout 0

# -------------------------------
# Create / update logins
# -------------------------------
$loginSql = @"
IF NOT EXISTS (SELECT 1 FROM sys.sql_logins WHERE name = 'dbreader')
    CREATE LOGIN [dbreader]
        WITH PASSWORD = '{{ db_reader_password }}', CHECK_POLICY = OFF;
ELSE
    ALTER LOGIN [dbreader]
        WITH PASSWORD = '{{ db_reader_password }}', CHECK_POLICY = OFF;

GRANT CONNECT SQL TO [dbreader];

IF NOT EXISTS (SELECT 1 FROM sys.sql_logins WHERE name = '{{ db }}Access')
    CREATE LOGIN [{{ db }}Access]
        WITH PASSWORD = '$password',
             CHECK_POLICY = OFF;
ELSE
    ALTER LOGIN [{{ db }}Access]
        WITH PASSWORD = '$password',
             CHECK_POLICY = OFF;

GRANT CONNECT SQL TO [{{ db }}Access];
GRANT VIEW ANY DEFINITION TO [{{ db }}Access];
GRANT VIEW SERVER STATE TO [{{ db }}Access];
"@

Invoke-Sqlcmd -ServerInstance $SQLServerInstance `
              -Credential $Cred `
              -Database master `
              -Query $loginSql `
              -TrustServerCertificate `
              -QueryTimeout 0

# -------------------------------
# Create database users + perms
# -------------------------------
$userSql = @"
USE [{{ db }}];

IF EXISTS (SELECT 1 FROM sys.database_principals WHERE name = N'{{ db }}Access')
    DROP USER [{{ db }}Access];
CREATE USER [{{ db }}Access] FOR LOGIN [{{ db }}Access];

IF EXISTS (SELECT 1 FROM sys.database_principals WHERE name = N'dbreader')
    DROP USER [dbreader];
CREATE USER [dbreader] FOR LOGIN [dbreader];

ALTER ROLE [db_owner]      ADD MEMBER [{{ db }}Access];
ALTER ROLE [db_datareader] ADD MEMBER [dbreader];

DENY INSERT, UPDATE, DELETE TO [dbreader];
"@

Invoke-Sqlcmd -ServerInstance $SQLServerInstance `
              -Credential $Cred `
              -Database "{{ db }}" `
              -Query $userSql `
              -TrustServerCertificate `
              -QueryTimeout 0

{% endfor %}

reg import ("D:\RegFiles\" + $AN_SQLDatabase + ".reg")
reg import D:\RegFiles\an_service_connection.reg
reg import D:\RegFiles\user_connection.reg

{% if not ProductIsExpress%}
reg import D:\RegFiles\AlloyDiscovery.reg
reg import D:\RegFiles\ad_service_connection.reg
{% endif %}

$rebuildFTSCatalogQuery = @"
DECLARE @sql nvarchar(max) = N'';

SELECT @sql +=
    N'ALTER FULLTEXT CATALOG '
    + c.name
    + N' REBUILD'
    + CHAR(13) + CHAR(10)
FROM sys.fulltext_catalogs c

EXEC sys.sp_executesql @sql;
"@

Invoke-Sqlcmd -ServerInstance $SQLServerInstance `
              -Credential $Cred `
              -Database $AN_SQLDatabase `
              -Query $rebuildFTSCatalogQuery `
              -TrustServerCertificate `
              -QueryTimeout 0

$AutomationServerReplacementQuery = @"
BEGIN TRAN UPDATE Automation_Servers SET [Last_Response] = NULL DELETE Automation_Servers INSERT Automation_Servers ([Host_Name], [Primary]) VALUES (N'{{ computer_name | trim }}', 1) COMMIT TRAN
"@

Invoke-Sqlcmd -ServerInstance $SQLServerInstance `
              -Credential $Cred `
              -Database $AN_SQLDatabase `
              -Query $AutomationServerReplacementQuery `
              -TrustServerCertificate `
              -QueryTimeout 0

Restart-Service AlloyAutomationServer

Import-Module WebAdministration

$siteName = "Alloy Navigator Site"

function Get-AlloyPortalIdFromWebConfig {
    param (
        [string]$WebConfigPath
    )

    try {
        [xml]$xml = Get-Content $WebConfigPath -ErrorAction Stop

        $node = $xml.configuration.appSettings.add |
            Where-Object { $_.key -eq 'AlloyPortalID' }

        return $node.value
    }
    catch {
        return $null
    }
}

$queriesToChangeIds = @{
    "/" = "update cfgApiSettings set ID = '{0}' where [Name] != 'default' and ID = (select top 1 ID from cfgSSPSettings order by Last_Used_Date desc)"
    "/wp" = "update cfgWebAppSettings set ID = '{0}'"
    "/hd" = "update cfgApiSettings set ID = '{0}' where [Name] != 'default' and ID = (select top 1 ID from cfgSSPSettings order by Last_Used_Date desc)"
    "/api" = "update cfgApiSettings set ID = '{0}'"
}

# Get applications + root
$apps = Get-WebApplication -Site $siteName
$site = Get-Website -Name $siteName

$allApps = $apps + [PSCustomObject]@{
    Path = "/"
    PhysicalPath = $site.PhysicalPath
} | ForEach-Object {

    $resolvedPath = [Environment]::ExpandEnvironmentVariables($_.PhysicalPath)
    $webConfigPath = Join-Path $resolvedPath "web.config"

    if (Test-Path $webConfigPath) {

        $portalId = Get-AlloyPortalIdFromWebConfig -WebConfigPath $webConfigPath
        if ($null -ne $portalId) {

        [PSCustomObject]@{
            Application   = $_.Path
            AlloyPortalID = $portalId
        }
        }
    }
}

$allApps | % {
  $portalQuery = ($queriesToChangeIds[$_.Application] -f $_.AlloyPortalID)
  Invoke-Sqlcmd -ServerInstance $SQLServerInstance `
              -Credential $Cred `
              -Database $AN_SQLDatabase `
              -Query $portalQuery `
              -TrustServerCertificate `
              -QueryTimeout 0
}

Invoke-Command -ArgumentList ($AN_AccessKeyName, $SQLServerInstance, $AN_SQLDatabase)  {
  param($AN_AccessKeyName, $SQLServerInstance, $AN_SQLDatabase)

  function UpdateWebConfig($InstallPath) {
      $FileName = "$InstallPath\Web.config"
      [xml]$xml = Get-Content -Path $FileName
      ($xml.configuration.appSettings.add | Where-Object { $_.key -eq "KeyName" }).value = $AN_AccessKeyName
      ($xml.configuration.appSettings.add | Where-Object { $_.key -eq "SQLServer" }).value = $SQLServerInstance
      ($xml.configuration.appSettings.add | Where-Object { $_.key -eq "Database" }).value = $AN_SQLDatabase
      $xml.Save($FileName)
  }

  function UpdateAppSettings($InstallPath) {
      $FileName = "$InstallPath\appsettings.json"
      $json = Get-Content -Path $FileName -Raw | ConvertFrom-Json
      $json.Anit."KeyName" = $AN_AccessKeyName
      $json.Anit."SQLServer" = $SQLServerInstance
      $json.Anit."Database" = $AN_SQLDatabase
      $json | ConvertTo-Json -Depth 10 | Set-Content -Path $FileName -Encoding UTF8
  }

  $DefaultsID = @(
      '{E850F970-051E-4B64-82CC-A1BF5324C370}',
      '{1766B1CF-887E-46C7-A9A0-4E204BEBC4F3}',
      '{031C27A5-6012-41B6-9EE0-459CF920A3DF}',
      '{C685B83D-C7C5-48F2-A509-CB4B048E7F1D}',
      '{85FFA55B-C1CE-454C-B111-F83EFAE376FE}',
      '{DD41C119-1E29-4814-9024-AB5B0D3AD00C}')

  Write-Output "Configuring web-portal SSP"
  Get-ChildItem "HKLM:\SOFTWARE\Alloy Software\Web Config" |
      Where-Object { $DefaultsID -notcontains $_.PSChildName } |
      ForEach-Object { UpdateAppSettings $_.GetValue("InstallPath") }

  Write-Output "Configuring web-portal API"
  Get-ChildItem "HKLM:\SOFTWARE\Alloy Software\Web Config API" |
      Where-Object { $DefaultsID -notcontains $_.PSChildName } |
      ForEach-Object { UpdateWebConfig $_.GetValue("InstallPath") }

  Write-Output "Configuring web-portal TP"
  Get-ChildItem "HKLM:\SOFTWARE\Alloy Software\Web Config Tech" |
      Where-Object { $DefaultsID -notcontains $_.PSChildName } |
      ForEach-Object { UpdateWebConfig $_.GetValue("InstallPath") }
}
